src/
 â””â”€â”€ main/
     â”œâ”€â”€ java/
     â”‚   â””â”€â”€ com/example/mocksolace/
     â”‚        â”œâ”€â”€ MockSolaceApplication.java
     â”‚        â”œâ”€â”€ config/MockSolaceConfig.java
     â”‚        â”œâ”€â”€ broker/MockSolaceBroker.java
     â”‚        â”œâ”€â”€ listener/MockSolaceListener.java
     â”‚        â”œâ”€â”€ publisher/MockSolacePublisherService.java
     â”‚        â””â”€â”€ controller/MockSolaceController.java
     â””â”€â”€ resources/
         â””â”€â”€ application.properties

spring.application.name=mock-solace
solace.jms.queue=hk-solace-queue
server.port=8080


package com.example.mocksolace;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MockSolaceApplication {
    public static void main(String[] args) {
        SpringApplication.run(MockSolaceApplication.class, args);
    }
}


package com.example.mocksolace.config;

import com.example.mocksolace.broker.MockSolaceBroker;
import jakarta.jms.ConnectionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.annotation.EnableJms;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;

@Configuration
@EnableJms
public class MockSolaceConfig {

    @Bean
    public ConnectionFactory connectionFactory(MockSolaceBroker broker) {
        // Our custom in-memory Solace-like broker acts as a ConnectionFactory
        return broker;
    }

    @Bean
    public DefaultJmsListenerContainerFactory contFactory(ConnectionFactory connectionFactory) {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        factory.setConcurrency("2");
        factory.setSessionTransacted(false);
        return factory;
    }
}


package com.example.mocksolace.broker;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import jakarta.jms.*;
import org.springframework.stereotype.Component;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * A lightweight, in-memory mock of Solace JMS broker.
 * Acts as both ConnectionFactory and Message queue.
 */
@Component
public class MockSolaceBroker implements ConnectionFactory, Connection, Session, Queue, MessageProducer {

    private final BlockingQueue<TextMessage> queue = new LinkedBlockingQueue<>();
    private boolean running = true;

    @PostConstruct
    public void init() {
        System.out.println("ðŸŸ¢ Mock Solace Broker started â€” simulating queue: hk-solace-queue");
        new Thread(this::simulateDelivery, "mock-solace-delivery-thread").start();
    }

    private void simulateDelivery() {
        while (running) {
            try {
                TextMessage msg = queue.take();
                System.out.println("ðŸ“¨ [Broker] Message delivered internally: " + msg.getText());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }

    // --- Simplified JMS interfaces ---
    @Override public Connection createConnection() { return this; }
    @Override public Session createSession(boolean transacted, int acknowledgeMode) { return this; }
    @Override public MessageProducer createProducer(Destination destination) { return this; }
    @Override public Queue createQueue(String queueName) { return this; }
    @Override public void send(Message message) {
        if (message instanceof TextMessage tm) queue.offer(tm);
    }

    public void sendText(String payload) throws JMSException {
        TextMessage msg = new MockTextMessage(payload);
        send(msg);
    }

    @Override public void start() {}
    @Override public void close() {}

    @PreDestroy
    public void shutdown() {
        running = false;
        System.out.println("ðŸ›‘ Mock Solace Broker stopped.");
    }

    // --- Internal TextMessage Implementation ---
    private static class MockTextMessage implements TextMessage {
        private String text;
        public MockTextMessage(String text) { this.text = text; }
        @Override public void setText(String s) { this.text = s; }
        @Override public String getText() { return text; }
        // No-ops for unused JMS methods
    }
}


package com.example.mocksolace.listener;

import jakarta.jms.JMSException;
import jakarta.jms.Message;
import jakarta.jms.TextMessage;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Component
public class MockSolaceListener {

    @JmsListener(destination = "${solace.jms.queue}", containerFactory = "contFactory", concurrency = "2")
    public void processMsg(Message message) throws JMSException {
        if (message instanceof TextMessage text) {
            System.out.println("ðŸ’¬ Listener received: " + text.getText());
        } else {
            System.out.println("ðŸ’¬ Received non-text message: " + message);
        }
    }
}


package com.example.mocksolace.publisher;

import com.example.mocksolace.broker.MockSolaceBroker;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import jakarta.jms.JMSException;
import org.springframework.stereotype.Service;

@Service
public class MockSolacePublisherService {

    private final MockSolaceBroker broker;

    public MockSolacePublisherService(MockSolaceBroker broker) {
        this.broker = broker;
    }

    @PostConstruct
    public void warmup() throws JMSException {
        System.out.println("ðŸš€ Starting mock publisher...");
        for (int i = 1; i <= 3; i++) {
            broker.sendText("Warm-up message " + i);
        }
    }

    public void send(String msg) throws JMSException {
        broker.sendText(msg);
        System.out.println("ðŸ“¤ Published: " + msg);
    }

    @PreDestroy
    public void shutdown() {
        System.out.println("ðŸ›‘ Mock publisher shutting down...");
    }
}


package com.example.mocksolace.controller;

import com.example.mocksolace.publisher.MockSolacePublisherService;
import jakarta.jms.JMSException;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/mock-solace")
public class MockSolaceController {

    private final MockSolacePublisherService publisherService;

    public MockSolaceController(MockSolacePublisherService publisherService) {
        this.publisherService = publisherService;
    }

    @PostMapping("/send")
    public String sendMessage(@RequestParam String msg) throws JMSException {
        publisherService.send(msg);
        return "âœ… Mock message sent: " + msg;
    }
}





<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>mock-solace</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <name>Mock Solace Local JMS</name>
    <description>Self-contained Spring Boot mock for Solace JMS queues</description>

    <!-- âœ… Spring Boot parent -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.5</version>
        <relativePath/>
    </parent>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- âœ… Core Spring Boot -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <!-- âœ… JMS / Messaging Support -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-activemq</artifactId>
        </dependency>

        <!-- âœ… Jakarta JMS API (for Message, TextMessage, etc.) -->
        <dependency>
            <groupId>jakarta.jms</groupId>
            <artifactId>jakarta.jms-api</artifactId>
            <version>3.1.0</version>
        </dependency>

        <!-- âœ… Optional testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- âœ… Spring Boot plugin -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>

            <!-- âœ… Compiler settings -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>






<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.example</groupId>
  <artifactId>mock-solace-broker</artifactId>
  <version>1.0.0</version>
  <name>Mock Solace Broker (Embedded ActiveMQ)</name>
  <description>Embedded ActiveMQ broker that listens on tcp://localhost:55555</description>

  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.3.5</version>
    <relativePath/>
  </parent>

  <properties>
    <java.version>17</java.version>
    <activemq.version>5.18.3</activemq.version>
  </properties>

  <dependencies>
    <!-- Spring Boot core -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
    </dependency>

    <!-- (Optional) health endpoint at /actuator/health -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <!-- ActiveMQ broker runtime -->
    <dependency>
      <groupId>org.apache.activemq</groupId>
      <artifactId>activemq-broker</artifactId>
      <version>${activemq.version}</version>
    </dependency>

    <!-- ActiveMQ client (helps if you later add a tiny test sender inside this app) -->
    <dependency>
      <groupId>org.apache.activemq</groupId>
      <artifactId>activemq-client</artifactId>
      <version>${activemq.version}</version>
    </dependency>

    <!-- JMS API (Jakarta) -->
    <dependency>
      <groupId>jakarta.jms</groupId>
      <artifactId>jakarta.jms-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>

    <!-- Tests -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
        <configuration>
          <source>${java.version}</source>
          <target>${java.version}</target>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>


spring.application.name=mock-solace-broker

# ---- Broker bind host/port (0.0.0.0 to accept remote too; keep 127.0.0.1 if local-only) ----
mock.broker.bindHost=0.0.0.0
mock.broker.port=55555

# ---- Optional auth (set to true to require credentials) ----
mock.broker.auth.enabled=false
mock.broker.auth.user=admin
mock.broker.auth.password=admin

# ---- Memory only, no persistence (good for local/dev) ----
mock.broker.persistent=false

# Actuator health (optional)
management.endpoints.web.exposure.include=health,info



package com.example.mocksolacebroker;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MockSolaceBrokerApplication {
  public static void main(String[] args) {
    SpringApplication.run(MockSolaceBrokerApplication.class, args);
  }
}



package com.example.mocksolacebroker.config;

import org.apache.activemq.broker.BrokerService;
import org.apache.activemq.broker.region.policy.PolicyEntry;
import org.apache.activemq.broker.region.policy.PolicyMap;
import org.apache.activemq.security.SimpleAuthenticationPlugin;
import org.apache.activemq.transport.TransportConnector;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.net.URI;
import java.util.List;

@Configuration
public class EmbeddedBrokerConfig {

  @Value("${mock.broker.bindHost:0.0.0.0}")
  private String bindHost;

  @Value("${mock.broker.port:55555}")
  private int port;

  @Value("${mock.broker.persistent:false}")
  private boolean persistent;

  @Value("${mock.broker.auth.enabled:false}")
  private boolean authEnabled;

  @Value("${mock.broker.auth.user:admin}")
  private String user;

  @Value("${mock.broker.auth.password:admin}")
  private String password;

  @Bean(initMethod = "start", destroyMethod = "stop")
  public BrokerService embeddedActiveMqBroker() throws Exception {
    BrokerService broker = new BrokerService();
    broker.setBrokerName("mock-solace-embedded-broker");
    broker.setPersistent(persistent);
    broker.setUseJmx(false); // keep lightweight

    // Listen on tcp://<bindHost>:<port>
    TransportConnector connector = new TransportConnector();
    connector.setName("tcp");
    connector.setUri(new URI("tcp://" + bindHost + ":" + port));
    broker.addConnector(connector);

    // Optional simple auth
    if (authEnabled) {
      SimpleAuthenticationPlugin sap = new SimpleAuthenticationPlugin();
      sap.setUsers(List.of(
          new org.apache.activemq.security.AuthenticationUser(user, password, "users,admins")
      ));
      broker.setPlugins(new org.apache.activemq.broker.BrokerPlugin[]{sap});
    }

    // Optional: simple destination policy (auto-creates queues on first use)
    PolicyEntry entry = new PolicyEntry();
    entry.setQueue(">"); // applies to all queues
    PolicyMap map = new PolicyMap();
    map.setPolicyEntries(List.of(entry));
    broker.setDestinationPolicy(map);

    // Log the endpoint
    System.out.println("âœ… Embedded ActiveMQ started at tcp://" + bindHost + ":" + port +
        (authEnabled ? " (auth enabled)" : " (no auth)"));

    return broker;
  }
}



