src/
 â””â”€â”€ main/
     â”œâ”€â”€ java/
     â”‚   â””â”€â”€ com/example/mocksolace/
     â”‚        â”œâ”€â”€ MockSolaceApplication.java
     â”‚        â”œâ”€â”€ config/MockSolaceConfig.java
     â”‚        â”œâ”€â”€ broker/MockSolaceBroker.java
     â”‚        â”œâ”€â”€ listener/MockSolaceListener.java
     â”‚        â”œâ”€â”€ publisher/MockSolacePublisherService.java
     â”‚        â””â”€â”€ controller/MockSolaceController.java
     â””â”€â”€ resources/
         â””â”€â”€ application.properties

spring.application.name=mock-solace
solace.jms.queue=hk-solace-queue
server.port=8080


package com.example.mocksolace;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MockSolaceApplication {
    public static void main(String[] args) {
        SpringApplication.run(MockSolaceApplication.class, args);
    }
}


package com.example.mocksolace.config;

import com.example.mocksolace.broker.MockSolaceBroker;
import jakarta.jms.ConnectionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.annotation.EnableJms;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;

@Configuration
@EnableJms
public class MockSolaceConfig {

    @Bean
    public ConnectionFactory connectionFactory(MockSolaceBroker broker) {
        // Our custom in-memory Solace-like broker acts as a ConnectionFactory
        return broker;
    }

    @Bean
    public DefaultJmsListenerContainerFactory contFactory(ConnectionFactory connectionFactory) {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        factory.setConcurrency("2");
        factory.setSessionTransacted(false);
        return factory;
    }
}


package com.example.mocksolace.broker;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import jakarta.jms.*;
import org.springframework.stereotype.Component;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * A lightweight, in-memory mock of Solace JMS broker.
 * Acts as both ConnectionFactory and Message queue.
 */
@Component
public class MockSolaceBroker implements ConnectionFactory, Connection, Session, Queue, MessageProducer {

    private final BlockingQueue<TextMessage> queue = new LinkedBlockingQueue<>();
    private boolean running = true;

    @PostConstruct
    public void init() {
        System.out.println("ðŸŸ¢ Mock Solace Broker started â€” simulating queue: hk-solace-queue");
        new Thread(this::simulateDelivery, "mock-solace-delivery-thread").start();
    }

    private void simulateDelivery() {
        while (running) {
            try {
                TextMessage msg = queue.take();
                System.out.println("ðŸ“¨ [Broker] Message delivered internally: " + msg.getText());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }

    // --- Simplified JMS interfaces ---
    @Override public Connection createConnection() { return this; }
    @Override public Session createSession(boolean transacted, int acknowledgeMode) { return this; }
    @Override public MessageProducer createProducer(Destination destination) { return this; }
    @Override public Queue createQueue(String queueName) { return this; }
    @Override public void send(Message message) {
        if (message instanceof TextMessage tm) queue.offer(tm);
    }

    public void sendText(String payload) throws JMSException {
        TextMessage msg = new MockTextMessage(payload);
        send(msg);
    }

    @Override public void start() {}
    @Override public void close() {}

    @PreDestroy
    public void shutdown() {
        running = false;
        System.out.println("ðŸ›‘ Mock Solace Broker stopped.");
    }

    // --- Internal TextMessage Implementation ---
    private static class MockTextMessage implements TextMessage {
        private String text;
        public MockTextMessage(String text) { this.text = text; }
        @Override public void setText(String s) { this.text = s; }
        @Override public String getText() { return text; }
        // No-ops for unused JMS methods
    }
}


package com.example.mocksolace.listener;

import jakarta.jms.JMSException;
import jakarta.jms.Message;
import jakarta.jms.TextMessage;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Component
public class MockSolaceListener {

    @JmsListener(destination = "${solace.jms.queue}", containerFactory = "contFactory", concurrency = "2")
    public void processMsg(Message message) throws JMSException {
        if (message instanceof TextMessage text) {
            System.out.println("ðŸ’¬ Listener received: " + text.getText());
        } else {
            System.out.println("ðŸ’¬ Received non-text message: " + message);
        }
    }
}


package com.example.mocksolace.publisher;

import com.example.mocksolace.broker.MockSolaceBroker;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import jakarta.jms.JMSException;
import org.springframework.stereotype.Service;

@Service
public class MockSolacePublisherService {

    private final MockSolaceBroker broker;

    public MockSolacePublisherService(MockSolaceBroker broker) {
        this.broker = broker;
    }

    @PostConstruct
    public void warmup() throws JMSException {
        System.out.println("ðŸš€ Starting mock publisher...");
        for (int i = 1; i <= 3; i++) {
            broker.sendText("Warm-up message " + i);
        }
    }

    public void send(String msg) throws JMSException {
        broker.sendText(msg);
        System.out.println("ðŸ“¤ Published: " + msg);
    }

    @PreDestroy
    public void shutdown() {
        System.out.println("ðŸ›‘ Mock publisher shutting down...");
    }
}


package com.example.mocksolace.controller;

import com.example.mocksolace.publisher.MockSolacePublisherService;
import jakarta.jms.JMSException;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/mock-solace")
public class MockSolaceController {

    private final MockSolacePublisherService publisherService;

    public MockSolaceController(MockSolacePublisherService publisherService) {
        this.publisherService = publisherService;
    }

    @PostMapping("/send")
    public String sendMessage(@RequestParam String msg) throws JMSException {
        publisherService.send(msg);
        return "âœ… Mock message sent: " + msg;
    }
}





<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                             http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>mock-solace</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <name>Mock Solace Local JMS</name>
    <description>Self-contained Spring Boot mock for Solace JMS queues</description>

    <!-- âœ… Spring Boot parent -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.5</version>
        <relativePath/>
    </parent>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- âœ… Core Spring Boot -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <!-- âœ… JMS / Messaging Support -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-activemq</artifactId>
        </dependency>

        <!-- âœ… Jakarta JMS API (for Message, TextMessage, etc.) -->
        <dependency>
            <groupId>jakarta.jms</groupId>
            <artifactId>jakarta.jms-api</artifactId>
            <version>3.1.0</version>
        </dependency>

        <!-- âœ… Optional testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- âœ… Spring Boot plugin -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>

            <!-- âœ… Compiler settings -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>






<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.example</groupId>
  <artifactId>mock-solace-broker</artifactId>
  <version>1.0.0</version>
  <name>Mock Solace Broker (Embedded ActiveMQ)</name>
  <description>Embedded ActiveMQ broker that listens on tcp://localhost:55555</description>

  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.3.5</version>
    <relativePath/>
  </parent>

  <properties>
    <java.version>17</java.version>
    <activemq.version>5.18.3</activemq.version>
  </properties>

  <dependencies>
    <!-- Spring Boot core -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
    </dependency>

    <!-- (Optional) health endpoint at /actuator/health -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <!-- ActiveMQ broker runtime -->
    <dependency>
      <groupId>org.apache.activemq</groupId>
      <artifactId>activemq-broker</artifactId>
      <version>${activemq.version}</version>
    </dependency>

    <!-- ActiveMQ client (helps if you later add a tiny test sender inside this app) -->
    <dependency>
      <groupId>org.apache.activemq</groupId>
      <artifactId>activemq-client</artifactId>
      <version>${activemq.version}</version>
    </dependency>

    <!-- JMS API (Jakarta) -->
    <dependency>
      <groupId>jakarta.jms</groupId>
      <artifactId>jakarta.jms-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>

    <!-- Tests -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
        <configuration>
          <source>${java.version}</source>
          <target>${java.version}</target>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>


spring.application.name=mock-solace-broker

# ---- Broker bind host/port (0.0.0.0 to accept remote too; keep 127.0.0.1 if local-only) ----
mock.broker.bindHost=0.0.0.0
mock.broker.port=55555

# ---- Optional auth (set to true to require credentials) ----
mock.broker.auth.enabled=false
mock.broker.auth.user=admin
mock.broker.auth.password=admin

# ---- Memory only, no persistence (good for local/dev) ----
mock.broker.persistent=false

# Actuator health (optional)
management.endpoints.web.exposure.include=health,info



package com.example.mocksolacebroker;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MockSolaceBrokerApplication {
  public static void main(String[] args) {
    SpringApplication.run(MockSolaceBrokerApplication.class, args);
  }
}



package com.example.mocksolacebroker.config;

import org.apache.activemq.broker.BrokerService;
import org.apache.activemq.broker.region.policy.PolicyEntry;
import org.apache.activemq.broker.region.policy.PolicyMap;
import org.apache.activemq.security.SimpleAuthenticationPlugin;
import org.apache.activemq.transport.TransportConnector;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.net.URI;
import java.util.List;

@Configuration
public class EmbeddedBrokerConfig {

  @Value("${mock.broker.bindHost:0.0.0.0}")
  private String bindHost;

  @Value("${mock.broker.port:55555}")
  private int port;

  @Value("${mock.broker.persistent:false}")
  private boolean persistent;

  @Value("${mock.broker.auth.enabled:false}")
  private boolean authEnabled;

  @Value("${mock.broker.auth.user:admin}")
  private String user;

  @Value("${mock.broker.auth.password:admin}")
  private String password;

  @Bean(initMethod = "start", destroyMethod = "stop")
  public BrokerService embeddedActiveMqBroker() throws Exception {
    BrokerService broker = new BrokerService();
    broker.setBrokerName("mock-solace-embedded-broker");
    broker.setPersistent(persistent);
    broker.setUseJmx(false); // keep lightweight

    // Listen on tcp://<bindHost>:<port>
    TransportConnector connector = new TransportConnector();
    connector.setName("tcp");
    connector.setUri(new URI("tcp://" + bindHost + ":" + port));
    broker.addConnector(connector);

    // Optional simple auth
    if (authEnabled) {
      SimpleAuthenticationPlugin sap = new SimpleAuthenticationPlugin();
      sap.setUsers(List.of(
          new org.apache.activemq.security.AuthenticationUser(user, password, "users,admins")
      ));
      broker.setPlugins(new org.apache.activemq.broker.BrokerPlugin[]{sap});
    }

    // Optional: simple destination policy (auto-creates queues on first use)
    PolicyEntry entry = new PolicyEntry();
    entry.setQueue(">"); // applies to all queues
    PolicyMap map = new PolicyMap();
    map.setPolicyEntries(List.of(entry));
    broker.setDestinationPolicy(map);

    // Log the endpoint
    System.out.println("âœ… Embedded ActiveMQ started at tcp://" + bindHost + ":" + port +
        (authEnabled ? " (auth enabled)" : " (no auth)"));

    return broker;
  }
}











package com.example.mocksolace.broker;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import jakarta.jms.*;
import org.springframework.stereotype.Component;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * A lightweight, in-memory mock of a Solace JMS broker that supports multiple named queues.
 * It acts as a minimal ConnectionFactory so Spring Boot JMS can use it.
 */
@Component
public class MockSolaceBroker implements ConnectionFactory {

    private final Map<String, BlockingQueue<TextMessage>> queues = new ConcurrentHashMap<>();
    private boolean running = true;

    // ------------------------------------------------------------------------
    // Broker startup / shutdown
    // ------------------------------------------------------------------------

    @PostConstruct
    public void start() {
        System.out.println("ðŸŸ¢ Mock Solace Broker started â€” supporting multiple queues");
        new Thread(this::simulateDeliveryLoop, "mock-solace-delivery-thread").start();
    }

    @PreDestroy
    public void stop() {
        running = false;
        System.out.println("ðŸ›‘ Mock Solace Broker stopped.");
    }

    private void simulateDeliveryLoop() {
        try {
            while (running) {
                for (Map.Entry<String, BlockingQueue<TextMessage>> entry : queues.entrySet()) {
                    TextMessage msg = entry.getValue().poll();
                    if (msg != null) {
                        System.out.println("ðŸ“¨ [Broker] Delivered from " + entry.getKey() + ": " + msg.getText());
                    }
                }
                Thread.sleep(200);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // ------------------------------------------------------------------------
    // JMS ConnectionFactory
    // ------------------------------------------------------------------------

    @Override
    public Connection createConnection() {
        return new MockConnection();
    }

    @Override
    public Connection createConnection(String userName, String password) {
        return new MockConnection();
    }

    // ------------------------------------------------------------------------
    // Inner mock JMS classes
    // ------------------------------------------------------------------------

    private class MockConnection implements Connection {
        @Override
        public Session createSession(boolean transacted, int acknowledgeMode) {
            return new MockSession();
        }

        @Override public void start() {}
        @Override public void stop() {}
        @Override public void close() {}
        @Override public String getClientID() { return "mock-client"; }
        @Override public void setClientID(String id) {}
        @Override public ConnectionMetaData getMetaData() { return null; }
        @Override public ExceptionListener getExceptionListener() { return null; }
        @Override public void setExceptionListener(ExceptionListener listener) {}
        @Override public ConnectionConsumer createConnectionConsumer(Destination destination, String selector, ServerSessionPool pool, int maxMessages) { return null; }
        @Override public ConnectionConsumer createDurableConnectionConsumer(Topic topic, String subName, String selector, ServerSessionPool pool, int maxMessages) { return null; }
    }

    private class MockSession implements Session {
        @Override
        public Queue createQueue(String queueName) {
            queues.computeIfAbsent(queueName, name -> new LinkedBlockingQueue<>());
            System.out.println("ðŸ“¦ [Broker] Queue created/registered: " + queueName);
            return new MockQueue(queueName);
        }

        @Override
        public MessageProducer createProducer(Destination destination) {
            if (destination instanceof MockQueue mockQueue) {
                return new MockMessageProducer(mockQueue.queueName());
            }
            return new MockMessageProducer("default");
        }

        @Override
        public TextMessage createTextMessage(String text) {
            return new MockTextMessage(text);
        }

        // --- Unused JMS methods (no-ops) ---
        @Override public BytesMessage createBytesMessage() { return null; }
        @Override public MapMessage createMapMessage() { return null; }
        @Override public Message createMessage() { return null; }
        @Override public ObjectMessage createObjectMessage() { return null; }
        @Override public ObjectMessage createObjectMessage(Serializable object) { return null; }
        @Override public StreamMessage createStreamMessage() { return null; }
        @Override public TextMessage createTextMessage() { return new MockTextMessage(""); }
        @Override public boolean getTransacted() { return false; }
        @Override public int getAcknowledgeMode() { return Session.AUTO_ACKNOWLEDGE; }
        @Override public void commit() {}
        @Override public void rollback() {}
        @Override public void close() {}
        @Override public void recover() {}
        @Override public MessageListener getMessageListener() { return null; }
        @Override public void setMessageListener(MessageListener listener) {}
        @Override public void run() {}
        @Override public MessageConsumer createConsumer(Destination destination) { return null; }
        @Override public MessageConsumer createConsumer(Destination destination, String selector) { return null; }
        @Override public MessageConsumer createConsumer(Destination destination, String selector, boolean noLocal) { return null; }
        @Override public Topic createTopic(String topicName) { return null; }
        @Override public TopicSubscriber createDurableSubscriber(Topic topic, String name) { return null; }
        @Override public TopicSubscriber createDurableSubscriber(Topic topic, String name, String selector, boolean noLocal) { return null; }
        @Override public QueueBrowser createBrowser(Queue queue) { return null; }
        @Override public QueueBrowser createBrowser(Queue queue, String selector) { return null; }
        @Override public TemporaryQueue createTemporaryQueue() { return null; }
        @Override public TemporaryTopic createTemporaryTopic() { return null; }
        @Override public void unsubscribe(String name) {}
        @Override public void unsubscribe(String name, boolean force) {}
    }

    private record MockQueue(String queueName) implements Queue {
        @Override public String getQueueName() { return queueName; }
    }

    private class MockMessageProducer implements MessageProducer {
        private final String queueName;

        MockMessageProducer(String queueName) { this.queueName = queueName; }

        @Override
        public void send(Message message) {
            BlockingQueue<TextMessage> q = queues.computeIfAbsent(queueName, k -> new LinkedBlockingQueue<>());
            if (message instanceof TextMessage tm) {
                q.offer(tm);
                System.out.println("ðŸ“¤ [Producer] Sent to " + queueName + ": " + tm.getText());
            }
        }

        // no-op overloads
        @Override public void close() {}
        @Override public void send(Destination destination, Message message) { send(message); }
        @Override public void send(Message message, int deliveryMode, int priority, long timeToLive) { send(message); }
        @Override public void send(Destination destination, Message message, int deliveryMode, int priority, long timeToLive) { send(message); }
        @Override public void setDisableMessageID(boolean value) {}
        @Override public boolean getDisableMessageID() { return false; }
        @Override public void setDisableMessageTimestamp(boolean value) {}
        @Override public boolean getDisableMessageTimestamp() { return false; }
        @Override public void setDeliveryMode(int deliveryMode) {}
        @Override public int getDeliveryMode() { return DeliveryMode.NON_PERSISTENT; }
        @Override public void setPriority(int defaultPriority) {}
        @Override public int getPriority() { return 4; }
        @Override public void setTimeToLive(long timeToLive) {}
        @Override public long getTimeToLive() { return 0; }
        @Override public Destination getDestination() { return new MockQueue(queueName); }
    }

    private static class MockTextMessage implements TextMessage {
        private String text;
        public MockTextMessage(String text) { this.text = text; }
        @Override public void setText(String s) { this.text = s; }
        @Override public String getText() { return text; }
        @Override public void clearBody() {}
        @Override public <T> T getBody(Class<T> c) { return null; }

        // --- minimal header/property stubs ---
        @Override public void acknowledge() {}
        @Override public void clearProperties() {}
        @Override public boolean propertyExists(String name) { return false; }
        @Override public boolean getBooleanProperty(String name) { return false; }
        @Override public byte getByteProperty(String name) { return 0; }
        @Override public short getShortProperty(String name) { return 0; }
        @Override public int getIntProperty(String name) { return 0; }
        @Override public long getLongProperty(String name) { return 0; }
        @Override public float getFloatProperty(String name) { return 0; }
        @Override public double getDoubleProperty(String name) { return 0; }
        @Override public String getStringProperty(String name) { return null; }
        @Override public Object getObjectProperty(String name) { return null; }
        @Override public Enumeration<String> getPropertyNames() { return null; }
        @Override public void setBooleanProperty(String name, boolean value) {}
        @Override public void setByteProperty(String name, byte value) {}
        @Override public void setShortProperty(String name, short value) {}
        @Override public void setIntProperty(String name, int value) {}
        @Override public void setLongProperty(String name, long value) {}
        @Override public void setFloatProperty(String name, float value) {}
        @Override public void setDoubleProperty(String name, double value) {}
        @Override public void setStringProperty(String name, String value) {}
        @Override public void setObjectProperty(String name, Object value) {}
        @Override public void setJMSDeliveryMode(int deliveryMode) {}
        @Override public int getJMSDeliveryMode() { return DeliveryMode.NON_PERSISTENT; }
        @Override public void setJMSExpiration(long expiration) {}
        @Override public long getJMSExpiration() { return 0; }
        @Override public void setJMSPriority(int priority) {}
        @Override public int getJMSPriority() { return 4; }
        @Override public void setJMSMessageID(String id) {}
        @Override public String getJMSMessageID() { return "mock-id"; }
        @Override public void setJMSTimestamp(long timestamp) {}
        @Override public long getJMSTimestamp() { return 0; }
        @Override public void setJMSCorrelationID(String correlationID) {}
        @Override public String getJMSCorrelationID() { return null; }
        @Override public void setJMSReplyTo(Destination replyTo) {}
        @Override public Destination getJMSReplyTo() { return null; }
        @Override public void setJMSDestination(Destination destination) {}
        @Override public Destination getJMSDestination() { return null; }
        @Override public void setJMSDeliveryTime(long deliveryTime) {}
        @Override public long getJMSDeliveryTime() { return 0; }
        @Override public void setJMSType(String type) {}
        @Override public String getJMSType() { return "TextMessage"; }
        @Override public void setJMSRedelivered(boolean redelivered) {}
        @Override public boolean getJMSRedelivered() { return false; }
    }
}


package com.example.mocksolace.controller;

import com.example.mocksolace.publisher.MockSolacePublisherService;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.jms.JMSException;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/mock-solace")
public class MockSolaceController {

    private final MockSolacePublisherService publisherService;
    private final ObjectMapper objectMapper;

    public MockSolaceController(MockSolacePublisherService publisherService, ObjectMapper objectMapper) {
        this.publisherService = publisherService;
        this.objectMapper = objectMapper;
    }

    /**
     * Accepts any JSON payload and publishes it to the given queue.
     *
     * Example:
     * POST /mock-solace/send?queueName=orders
     * Body:
     * {
     *   "orderId": 123,
     *   "customer": { "name": "Avinash", "city": "Chennai" },
     *   "items": ["apple", "banana"]
     * }
     */
    @PostMapping(value = "/send", consumes = "application/json", produces = "application/json")
    public Map<String, Object> sendJsonMessage(
            @RequestParam String queueName,
            @RequestBody Map<String, Object> payload) throws JMSException {

        // Convert the incoming JSON map to string
        String jsonString;
        try {
            jsonString = objectMapper.writeValueAsString(payload);
        } catch (Exception e) {
            throw new RuntimeException("Failed to convert JSON", e);
        }

        publisherService.send(queueName, jsonString);

        return Map.of(
                "status", "âœ… Message sent",
                "queue", queueName,
                "payload", payload
        );
    }
}



package com.example.mocksolace.publisher;

import com.example.mocksolace.broker.MockSolaceBroker;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import jakarta.jms.*;
import org.springframework.stereotype.Service;

@Service
public class MockSolacePublisherService {

    private final MockSolaceBroker broker;

    public MockSolacePublisherService(MockSolaceBroker broker) {
        this.broker = broker;
    }

    @PostConstruct
    public void warmup() throws JMSException {
        System.out.println("ðŸš€ Starting mock publisher...");
        send("hk-solace-queue", "{\"warmup\":\"message 1\"}");
        send("hk-solace-queue", "{\"warmup\":\"message 2\"}");
    }

    /**
     * Send message as JSON string to specific queue.
     */
    public void send(String queueName, String jsonPayload) throws JMSException {
        Connection conn = broker.createConnection();
        Session session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue queue = session.createQueue(queueName);
        MessageProducer producer = session.createProducer(queue);

        TextMessage textMessage = session.createTextMessage(jsonPayload);
        producer.send(textMessage);

        producer.close();
        session.close();
        conn.close();

        System.out.println("ðŸ“¤ Published JSON to [" + queueName + "]: " + jsonPayload);
    }

    @PreDestroy
    public void shutdown() {
        System.out.println("ðŸ›‘ Mock publisher shutting down...");
    }
}






package com.example.mocksolace.broker;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import jakarta.jms.*;
import org.springframework.stereotype.Component;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Map;
import java.util.concurrent.*;

/**
 * A fully compilable in-memory mock JMS broker supporting multiple queues.
 * It satisfies all jakarta.jms 3.1 interfaces with stubbed methods.
 */
@Component
public class MockSolaceBroker implements ConnectionFactory {

    private final Map<String, BlockingQueue<TextMessage>> queues = new ConcurrentHashMap<>();
    private volatile boolean running = true;

    @PostConstruct
    public void start() {
        System.out.println("ðŸŸ¢ Mock Solace Broker started â€” multi-queue mode");
        new Thread(this::deliveryLoop, "mock-solace-loop").start();
    }

    @PreDestroy
    public void stop() {
        running = false;
        System.out.println("ðŸ›‘ Mock Solace Broker stopped.");
    }

    private void deliveryLoop() {
        while (running) {
            queues.forEach((name, q) -> {
                TextMessage msg = q.poll();
                if (msg != null) {
                    try {
                        System.out.println("ðŸ“¨ [Broker] Delivered from " + name + ": " + msg.getText());
                    } catch (JMSException e) {
                        e.printStackTrace();
                    }
                }
            });
            try { Thread.sleep(200); } catch (InterruptedException ignored) {}
        }
    }

    // ------------------------------------------------------------------------
    // ConnectionFactory
    // ------------------------------------------------------------------------
    @Override
    public Connection createConnection() { return new MockConnection(); }

    @Override
    public Connection createConnection(String username, String password) { return new MockConnection(); }

    // ------------------------------------------------------------------------
    // Mock inner classes
    // ------------------------------------------------------------------------
    private class MockConnection implements Connection {

        @Override
        public Session createSession(boolean transacted, int acknowledgeMode) { return new MockSession(); }

        @Override public void start() {}
        @Override public void stop() {}
        @Override public void close() {}
        @Override public String getClientID() { return "mock-client"; }
        @Override public void setClientID(String id) {}
        @Override public ConnectionMetaData getMetaData() { return null; }
        @Override public ExceptionListener getExceptionListener() { return null; }
        @Override public void setExceptionListener(ExceptionListener listener) {}
        @Override public ConnectionConsumer createConnectionConsumer(Destination dest, String selector, ServerSessionPool pool, int maxMessages) { return null; }
        @Override public ConnectionConsumer createDurableConnectionConsumer(Topic topic, String subName, String selector, ServerSessionPool pool, int maxMessages) { return null; }
    }

    private class MockSession implements Session {

        @Override public BytesMessage createBytesMessage() { return null; }
        @Override public MapMessage createMapMessage() { return null; }
        @Override public Message createMessage() { return null; }
        @Override public ObjectMessage createObjectMessage() { return null; }
        @Override public ObjectMessage createObjectMessage(Serializable object) { return null; }
        @Override public StreamMessage createStreamMessage() { return null; }

        @Override public TextMessage createTextMessage() { return new MockTextMessage(""); }
        @Override public TextMessage createTextMessage(String text) { return new MockTextMessage(text); }

        @Override
        public boolean getTransacted() { return false; }
        @Override
        public int getAcknowledgeMode() { return Session.AUTO_ACKNOWLEDGE; }

        @Override public void commit() {}
        @Override public void rollback() {}
        @Override public void close() {}
        @Override public void recover() {}

        @Override public MessageListener getMessageListener() { return null; }
        @Override public void setMessageListener(MessageListener listener) {}
        @Override public void run() {}

        @Override public MessageProducer createProducer(Destination destination) {
            String qName = (destination instanceof MockQueue mq) ? mq.getQueueName() : "default";
            return new MockProducer(qName);
        }

        @Override public MessageConsumer createConsumer(Destination destination) { return null; }
        @Override public MessageConsumer createConsumer(Destination destination, String selector) { return null; }
        @Override public MessageConsumer createConsumer(Destination destination, String selector, boolean noLocal) { return null; }

        @Override public Queue createQueue(String queueName) {
            queues.computeIfAbsent(queueName, k -> new LinkedBlockingQueue<>());
            System.out.println("ðŸ“¦ Queue created/registered: " + queueName);
            return new MockQueue(queueName);
        }

        @Override public Topic createTopic(String topicName) { return null; }
        @Override public TopicSubscriber createDurableSubscriber(Topic topic, String name) { return null; }
        @Override public TopicSubscriber createDurableSubscriber(Topic topic, String name, String selector, boolean noLocal) { return null; }

        @Override public QueueBrowser createBrowser(Queue queue) { return null; }
        @Override public QueueBrowser createBrowser(Queue queue, String selector) { return null; }
        @Override public TemporaryQueue createTemporaryQueue() { return null; }
        @Override public TemporaryTopic createTemporaryTopic() { return null; }
        @Override public void unsubscribe(String name) {}
        @Override public void unsubscribe(String name, boolean force) {}
    }

    private record MockQueue(String queueName) implements Queue {
        @Override public String getQueueName() { return queueName; }
    }

    private class MockProducer implements MessageProducer {
        private final String queueName;
        MockProducer(String queueName) { this.queueName = queueName; }

        @Override
        public void send(Message message) throws JMSException {
            BlockingQueue<TextMessage> q = queues.computeIfAbsent(queueName, k -> new LinkedBlockingQueue<>());
            if (message instanceof TextMessage tm) {
                q.offer(tm);
                System.out.println("ðŸ“¤ [Producer] Sent to " + queueName + ": " + tm.getText());
            }
        }

        // --- Remaining stubs ---
        @Override public void send(Destination dest, Message msg) throws JMSException { send(msg); }
        @Override public void send(Message msg, int dm, int p, long ttl) throws JMSException { send(msg); }
        @Override public void send(Destination dest, Message msg, int dm, int p, long ttl) throws JMSException { send(msg); }
        @Override public void close() {}
        @Override public void setDisableMessageID(boolean v) {}
        @Override public boolean getDisableMessageID() { return false; }
        @Override public void setDisableMessageTimestamp(boolean v) {}
        @Override public boolean getDisableMessageTimestamp() { return false; }
        @Override public void setDeliveryMode(int dm) {}
        @Override public int getDeliveryMode() { return DeliveryMode.NON_PERSISTENT; }
        @Override public void setPriority(int p) {}
        @Override public int getPriority() { return 4; }
        @Override public void setTimeToLive(long ttl) {}
        @Override public long getTimeToLive() { return 0; }
        @Override public Destination getDestination() { return new MockQueue(queueName); }
    }

    private static class MockTextMessage implements TextMessage {
        private String text;
        public MockTextMessage(String text) { this.text = text; }

        @Override public void setText(String s) { this.text = s; }
        @Override public String getText() { return text; }

        // --- JMS stubs for compilation ---
        @Override public void clearBody() {}
        @Override public <T> T getBody(Class<T> c) { return null; }
        @Override public void acknowledge() {}
        @Override public void clearProperties() {}
        @Override public boolean propertyExists(String name) { return false; }
        @Override public boolean getBooleanProperty(String name) { return false; }
        @Override public byte getByteProperty(String name) { return 0; }
        @Override public short getShortProperty(String name) { return 0; }
        @Override public int getIntProperty(String name) { return 0; }
        @Override public long getLongProperty(String name) { return 0; }
        @Override public float getFloatProperty(String name) { return 0; }
        @Override public double getDoubleProperty(String name) { return 0; }
        @Override public String getStringProperty(String name) { return null; }
        @Override public Object getObjectProperty(String name) { return null; }
        @Override public Enumeration<String> getPropertyNames() { return null; }
        @Override public void setBooleanProperty(String name, boolean value) {}
        @Override public void setByteProperty(String name, byte value) {}
        @Override public void setShortProperty(String name, short value) {}
        @Override public void setIntProperty(String name, int value) {}
        @Override public void setLongProperty(String name, long value) {}
        @Override public void setFloatProperty(String name, float value) {}
        @Override public void setDoubleProperty(String name, double value) {}
        @Override public void setStringProperty(String name, String value) {}
        @Override public void setObjectProperty(String name, Object value) {}
        @Override public void setJMSDeliveryMode(int deliveryMode) {}
        @Override public int getJMSDeliveryMode() { return DeliveryMode.NON_PERSISTENT; }
        @Override public void setJMSExpiration(long expiration) {}
        @Override public long getJMSExpiration() { return 0; }
        @Override public void setJMSPriority(int priority) {}
        @Override public int getJMSPriority() { return 4; }
        @Override public void setJMSMessageID(String id) {}
        @Override public String getJMSMessageID() { return "mock-id"; }
        @Override public void setJMSTimestamp(long timestamp) {}
        @Override public long getJMSTimestamp() { return 0; }
        @Override public void setJMSCorrelationID(String correlationID) {}
        @Override public String getJMSCorrelationID() { return null; }
        @Override public void setJMSReplyTo(Destination replyTo) {}
        @Override public Destination getJMSReplyTo() { return null; }
        @Override public void setJMSDestination(Destination destination) {}
        @Override public Destination getJMSDestination() { return null; }
        @Override public void setJMSDeliveryTime(long deliveryTime) {}
        @Override public long getJMSDeliveryTime() { return 0; }
        @Override public void setJMSType(String type) {}
        @Override public String getJMSType() { return "TextMessage"; }
        @Override public void setJMSRedelivered(boolean redelivered) {}
        @Override public boolean getJMSRedelivered() { return false; }
    }
}

