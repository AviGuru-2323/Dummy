Absolutely! Here's a **complete Spring Boot WebFlux sidecar project** that:

* Uses **WebFlux + Netty** (non-blocking).
* Intercepts all requests (`/**`) or can filter specific patterns.
* Uses **WebClient** with **disabled SSL validation**.
* Prints the response before sending it back.
* Adds custom headers.

---

## 1️⃣ `pom.xml`

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>webflux-proxy-sidecar</artifactId>
    <version>1.0.0</version>

    <properties>
        <java.version>17</java.version>
        <spring.boot.version>3.3.5</spring.boot.version>
        <reactor.netty.version>1.1.12</reactor.netty.version>
    </properties>

    <dependencies>
        <!-- Spring Boot WebFlux -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- Netty (WebFlux uses Reactor Netty by default) -->
        <dependency>
            <groupId>io.projectreactor.netty</groupId>
            <artifactId>reactor-netty-http</artifactId>
            <version>${reactor.netty.version}</version>
        </dependency>

        <!-- Optional: Logging -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- Spring Boot Maven plugin -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring.boot.version}</version>
            </plugin>
        </plugins>
    </build>
</project>
```

---

## 2️⃣ `ProxyApplication.java`

```java
package com.example.proxy;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProxyApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProxyApplication.class, args);
    }
}
```

---

## 3️⃣ `WebClientConfig.java`

```java
package com.example.proxy;

import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.netty.http.client.HttpClient;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;

@Configuration
public class WebClientConfig {

    @Bean
    public WebClient webClient() {
        HttpClient httpClient = HttpClient.create()
            .secure(spec -> spec.sslContext(
                SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE)
            ));

        return WebClient.builder()
                .clientConnector(new ReactorClientHttpConnector(httpClient))
                .build();
    }
}
```

---

## 4️⃣ `ProxyController.java`

```java
package com.example.proxy;

import org.springframework.core.io.buffer.DataBufferFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.reactive.function.client.ClientResponse;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@RestController
public class ProxyController {

    private final WebClient webClient;

    public ProxyController(WebClient webClient) {
        this.webClient = webClient;
    }

    @RequestMapping("/**")
    public Mono<Void> proxy(ServerWebExchange exchange) {
        ServerHttpRequest request = exchange.getRequest();
        ServerHttpResponse response = exchange.getResponse();
        DataBufferFactory bufferFactory = response.bufferFactory();

        // Construct target URL
        String targetHost = request.getHeaders().getFirst(HttpHeaders.HOST);
        String scheme = request.getURI().getScheme() != null ? request.getURI().getScheme() : "http";
        String path = request.getURI().getRawPath();
        String query = request.getURI().getRawQuery();
        String targetUrl = scheme + "://" + targetHost + path + (query != null ? "?" + query : "");

        return webClient.method(HttpMethod.valueOf(request.getMethodValue()))
                .uri(targetUrl)
                .headers(headers -> {
                    request.getHeaders().forEach(headers::put);
                    headers.add("X-Extra-Header", "added-by-proxy");
                })
                .body(request.getBody(), byte[].class)
                .exchangeToMono((ClientResponse clientResponse) -> {
                    response.setStatusCode(clientResponse.statusCode());
                    clientResponse.headers().asHttpHeaders()
                            .forEach((k, v) -> response.getHeaders().put(k, v));

                    // Print response before sending
                    return clientResponse.bodyToMono(String.class)
                            .flatMap(body -> {
                                System.out.println("Response body:\n" + body);
                                return response.writeWith(
                                        Mono.just(bufferFactory.wrap(body.getBytes()))
                                );
                            });
                });
    }
}
```

---

## 5️⃣ `application.properties`

```properties
server.port=8085
spring.main.web-application-type=reactive
```

---

### ✅ How it works

* The **WebFlux Netty server** listens on port `8085`.
* All requests (`/**`) are intercepted by `ProxyController`.
* The proxy forwards the request to the **original host**.
* Adds `X-Extra-Header`.
* Prints the response body in console before sending it back.
* SSL validation is **disabled** for outgoing HTTPS requests.

---

### 6️⃣ Running the sidecar locally

```bash
mvn spring-boot:run
```

Your **Quarkus apps** can be configured to use the proxy via:

* `-Dhttp.proxyHost=localhost -Dhttp.proxyPort=8085`
* Or call the proxy URL directly (`http://localhost:8085/...`).

---

If you want, I can provide a **version that only proxies certain URL patterns** instead of all requests (`/**`), and also **streams large responses without loading into memory**. This is more efficient for production sidecars.

Do you want me to provide that optimized streaming version?
